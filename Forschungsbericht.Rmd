---
title: "226305 Forschungsbericht"
subtitle: "Analyse des SpaceX Netzwerkes"
date: "WS 20/21"
author: "Ricarda Müterthies, Sebastian Brüne, Raouf Allaham, Tom Beyer | rm057@hdm-stuttgart.de, sb274@hdm-stuttgart.de, ma106@hdm-stuttgart.de, tb145@hdm-stuttgart.de"
output: html_notebook
---

# Einleitung
Wir wollen die interne Struktur des Vorstandes von SpaceX analysieren im Bezug auf die Verbindung zu anderen Raumfahrtunternehmen. Unser Ziel ist die Darstellung der Struktur der einzelnen Personen und wie sie zu verschiedenen Unternehmen beruflich stehen.


# Vorarbeiten und vergleichbare Studien
## Forschungsstand

Das Forschungsdesign lehnt sich zum einen an die lange Tradition der Netzwerkanalyse in der Schulforschung an (XXXX). Es greift zudem die klassische Studie von Krackhardt (XXXX) auf, der ein Ratsuche und Unterstützungsnetzwerk in einem Unternehmen untersuchte. 

## Arbeitshypothesen

Anfangshypothese: Alles miteinander verknüpft, viele Überschneidungen der Knoten, Raumfahrtunternehmen haben änhliche Vorstände. Vorstände arbeiten mehr zusammen und kennen sich mehr, Verknüpfungen sind breiter
Zwischenergebnis: Nach ersten Recherchen stellte sich das Gegenteil heraus... wenig Konktakte, einzelne Cluster, wenig Verknüpfungen der verschiedenen Knoten der Raumfahrtunternehmen
Endergebnis: Nach intensiver Recherche stellte sich heraus dass die Unternehmen nicht gut zueinander vernetzt sind. Akteure sind nur durch einzelne Ereignise verbunden (zb Uni, Hobbys, Engagements). Fast gar keine Verknüpfungen verhanden.

# Datenerhebung: Zugang, Bereinigung und Codebuch

## Zugang
LinkedIn, diverse Websiten: Boards, Unternehmenswebsiten, Vorstände etc..

## Bereinigung des Datensatzes
Keine Anonymisierung nötig da es sich um öffentliche Personen handelt

## Codebuch
Das [Codebuch](https://github.com/tomllb/SpaceXNetzwerk/blob/master/Codebuch.md) beschreibt die Variablen, Relationen und Gewichte des Netzwerks und ist ebenfalls auf Github hinterlegt. ( abändern in passende Begriffe )

# Analyse und Interpretation

# Das Gesamtnetzwerk

Das gerichtete Gesamtnetzwerk umfasst XX Knoten und XXX Beziehungen (siehe igraph-Objekt).

```{r Gesamnetzwerk erstellen, echo=FALSE, message=FALSE, warning=FALSE, paged.print=TRUE}

library(igraph)

# Einlesen der Edge- und Nodelist
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

# Matrix erstellen
edgematrix <-as.matrix(el)

# Zusammenführen von Edge- und Nodelist als igraph-Objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Parameter zu Beschreibung des Netzwerks

## ist das Netzwerk bereits vereinfacht?
is.simple(s)

## besteht das Netzwerk aus Komponenten?
## wenn ja, wie vielen?
is.connected(s)
components(s)

## Dichte des Netzwerks
edge_density(s, loops=FALSE)

## Umfang des Netzwerks
diameter(s)

## Pfaddistanzen (Distance)
farthest_vertices(s)

```

Das Hauptnetzwerk besteht aus zwei Komponenten mit 32 und 6 Knoten, die nicht miteinander verbunden sind. Die Dichte im Netzwerk beträgt 12,51 Prozent von allen möglichen Verbindungen. Die maximale Pfaddistanz beträgt 18 Schritte.

```{r Einfache Visualisierung des erstellten Objekt, fig.height=10, fig.width=14, message=TRUE, warning=TRUE, paged.print=TRUE}

# Pro-Tipp: die Ausgabe jedes "chunks" lässt sich über das Rädchen direkt über dem Textfeld einstellen. Hier habe ich die Bildfläche auf 10 auf 16 Inches eingestellt, d.h. das Netzwerk wird automatisch auf eine Fläche von 10 auf 16 Inches geplottet. Für den Anfang empfehle ich immer bei Netzwerken bis 50 Knoten mit dem Kamada-Kawai Algorithmus zu arbeiten, weil hier die Knoten immer an die gleiche Position gesetzt werden und wir dadurch Abweichungen besser erkennen können.

plot(s,
     asp=0, 
     layout=layout_with_kk,
     edge.arrow.size=.5,
     vertex.size=10,
     main ="Übersicht Gesamtnetzwerk")
```

*Vereinfachtes Gesamtnetzwerk*
Der erste Überblick zeigt, dass das Netzwerk schnell unübersichtlich wird, weil hier drei Beziehungsarten mit zum Teil mehreren Gewichten in einer Abbildung dargestellt werden.
Deshalb ist es sinnvoll, ein vereinfachtes Gesamtnetzwerk zu erstellen. Vereinfacht bedeutet, dass die unterschiedlichen Beziehungsarten ignoriert werden und dafür die Gewichte des Hilfs- und Ratsuche Netzwerk zusammengefasst werden (um das Ergebnis nicht zu verfälschen, wird das Beziehungsnetzwerk vorher gelöscht)

```{r Vereinfachtes Gesamtnetzwerk, fig.height=8, fig.width=12, message=FALSE, warning=FALSE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

# simplify Gesamtnetzwerk 
# Um die Ergebnisse der Gewichte nicht zu verfälschen, werden die Edge-Attribute relation und complicated gelöscht.
s <- delete_edge_attr(s, "relation")
s <- delete_edge_attr(s, "complicated")
list.edge.attributes(s)

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Dafür lassen sich die Beziehungsstärken aber besser abbilden. Dies ist später für die Analyse von dyadischen Beziehungen wichtig.
is_simple(s)
s_sim <- simplify(s,edge.attr.comb=list(weight="sum"))
is_simple(s_sim)
s_sim

# die aggregierten Werte für weight von s_sim werden deutlich.
list.edge.attributes(s_sim)
edge.attributes(s_sim)$weight

# einfache Visualisierung des aggregierten Netzwerks
plot(s_sim,
     layout=layout_nicely,
     edge.arrow.size=.5,
     vertex.size=8,
     edge.curved=.2,
     edge.curved=curve_multiple(s_sim),
     main="Gesamtnetzwerk vereinfacht",
     sub="aggregierte Gewichte von Ratsuche und Zusammenarbeit")
```

Die Anzahl der Knoten ist gleich geblieben (38), aber die Anzahl der Kanten hat sich auf 124 reduziert. Die Verteilung des Gewichts lässt klare Präferenzen innerhalb des Netzwerks zwischen einzelnen Dyaden zeigen. Diese Vorselektion ist später wichtig, um starke Beziehungspaare innerhalb des Netzwerks zu analysieren.


```{r 2 Übersicht Netzwerkattribute}
list.vertex.attributes(s)
# vertex.attributes(s)
list.edge.attributes(s)
# edge.attributes(s)
# edge.attributes(s)$weight
```

Das Netzwerk hat nach dem [](# Error : selection is not a URL) folgende Attribute:

*Vertex-Attribute*
- name: Name des Knotens, anonym codiert von 1 bis 38
- sex: Geschlecht 1 weiblich, 2 männlich, 3 divers
- crpr: Vertiefungsrichtung (1 CR, 2 PR)
- age: Alter 1 bis 20, 2 21-22, 3 23-24, 4 25 und älter
- smoke: Nichtraucher 1, Raucher 2
- tatoo: nein 1, ja 2
- eyes: Augenfarbe: 1 grün, 2 blau, 3 braun, 4 blau.
- hair: Haarfarbe: 1 braun, 2 schwarz, 3 blond, 4 rot

Die Vertex-Attribute treffen auf alle Knoten zu.

Die gesetzten Werte der Attribute lassen sich durch die Selektion des entsprechenden Attributes auslesen.

```{r 2 Auslesen von Attributen }
vertex.attributes(s)$sex
edge.attributes(s)$complicated
# wichtig: sind keine Werte gesetzt, dann behandelt igraph den Wert als NA, also not available. Das ist wichtig für die Kalkulation der Netzwerkbeziehungen. Complicated ist ein Wert der sich nur auf das Teilnetzwerk love bezieht und spielt deshalb für die anderen 2x76 Beziehungen keine Rolle. 

```

*Edge-Attribute*
- weight: Erste Nennung (Primärer Kontakt). Zweite Nennung (Sekunderärer Kontakt)
- relation: Ratsuche (help), Zusammenarbeit (work), Liebesbeziehung (love)
- complicated: bezieht sich nur auf das Teilnetzwerk Liebesbeziehung

Die Edge-Attribute sind unterschiedlich verteilt. Durch die Erhebung haben die Studierenden ein Ratsuchenetzwerk (Wen fragst Du um Rat?) und ein Zusammenarbeitsnetzwerk (Mit wem arbeitest Du am liebsten zusammen?) angeben müssen. Für beide Fragen gab es eine erste und ein zweite Nennung. Die erste Nennung wird entsprechend höher gewichtet. Die Fragen waren verpflichtend.
Das bedeutet, dass die Edges sich wie folgt verteilen: 38*2 = 76 Beziehungenangaben für jeweils help und work.

Das bedeutet, dass es folgende Teilnetzwerke aufgrund der Edge-Attribute gibt:
1) h3 Hilfsnetzwerk, erste Nennung, d.h. starke Gewichtung (Wert 3)
2) h1 Hilfsnetzwerk, zweite Nennung, d.h. weniger starke Gewichung (Wert 1)
3) h Hilfsnetzwerk mit der Zusammenfassung beider Gewichte über simplifiy()

1) w3 Zusammenarbeit: erste Nennung, d.h. starke Gewichtung (Wert 3)
2) w1 Zusammenarbeit: zweite Nennung, d.h. weniger starke Gewichung (Wert 1)
3) w Zusammenarbeit mit der Zusammenfassung beider Gewichte über simplify()

Wichtig: Für die Analyse der jeweiligen Teilnetzwerke müssen die anderen Relationen insbesonder love gelöscht werden, weil sonst der simplify-Befehl nicht ausgeführt werden kann.

Das Beziehungsnetzwerk love (l) kennt folgende Ausprägungen:
1) l_pair reziproke Paarbeziehung (1)
2) l_tinder Tinder-Like, muss nicht reziprok sein (2)
3) l_crush einseitig verliebte Situtation (3)

Wichtig: die Werte sind keine Gewichte, sondern unterschiedliche Beziehungstypen und gelten nur für das Teilnetzwerk "love". Für die Analyse der anderen Beziehungen empfiehlt es sich, das edge.attribut "love" zu löschen.

## 4.2 Analyse der Teilnetzwerke 

### 4.2.1 Teilnetzwerke nach Beziehungsart (Edge-Attribute)

Das Netzwerk besteht aus drei Beziehungsarten: Ratsuche (zukünftig Teilnetzwerk h für help), Zusammenarbeit (zukünftig Teilnetzwerk w für work) und Liebesbeziehung (zukünftig Teilnetzwerk l für love). Die Teilnetzwerke work und help sind gewichtet, d.h. die erste Nennung wurde mit 3 codiert und die zweite Nennung mit 1. Das bedeutet, dass jedes Teilnetzwerk über 76 Beziehungen hat (38 Mal eine erste Nennung und 38 Mal eine zweite Nennung). Die Liebesbeziehung wurde nicht gewichtet, sondern nach unterschiedlichen Beziehungsarten unterteilt.

*Generelle Teilnetzwerke*

- help (gesamt)
- work (gesamt)
- love (gesamt)

```{r Teilnetzwerke erstellen und vereinfachen, message=FALSE, warning=FALSE, paged.print=FALSE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

work <- subgraph.edges(s, E(s)[relation==1]) 
help <- subgraph.edges(s, E(s)[relation==2])
love <- subgraph.edges(s, E(s)[relation==3])

work # das Netzwerk hat nur noch 76 Kanten (also 2*38 Antworten)
# help # das sind eigenständige igraph-objekte
# love


```

Damit die Netzwerke gut vereinfacht werden können sollten die ungenutzen edge-attribute wie relation oder complicated gelöscht werden, damit die jeweiligen Hauptnetzwerke eigenständig verglichen werden können.

```{r Nicht benötigte Edge-Attribute löschen, message=FALSE, warning=FALSE, paged.print=TRUE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# Nicht benötigte Edge-Attribute löschen
# In den Teilnetzwerken sind edge-Attribute vorhanden, die wir für eine weitere Vereinfachung des Netzwerks nicht benötigen. Das gilt v.a. für die Teilnetzwerke work und help.

work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")

help <- delete_edge_attr(help, "relation")
help <- delete_edge_attr(help, "complicated")

love <- delete_edge_attr(love, "relation")
# bei love bleibt die Kategorie complicated erhalten, da sich diese ja direkt auf die Art der Liebesbeziehung bezieht. Bei erstellten Liebesnetzwerk werden auch alle Knoten gelöscht, die keine Beziehungskategorie haben, d.h. das Netzwerk ist automatisch kleiner. 

#edge.attributes(love)$complicated

# mit dem Befehl simplify() lassen sich Edge-Attribute wie das Gewicht zusammenfassen. Damit ist zwar nicht mehr nachvollziehbar, um welche Beziehung es sich handelt. Dafür lassen sich die Beziehungsstärken aber besser abbilden. Dies ist später für die Analyse von dyadischen Beziehungen wichtig.
# 
is_simple(work)
w_sim <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(w_sim)
w_sim

is_simple(help)
h_sim <- simplify(help,edge.attr.comb=list(weight="sum"))
is_simple(h_sim)
h_sim


# definiert, dass 3 Abbildungen in einer Zeile stehen
par(mfrow=c(1,3), mar=c(2,0,2,0)) 

plot(w_sim, layout=layout_nicely,
     edge.arrow.size=.2,
     edge.color="blue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main=" Teilnetzwerk Zusammenarbeit",
     sub="38 Knoten mit 75 Kanten")
plot(h_sim, layout=layout_nicely, 
     edge.arrow.size=.2,
     edge.color="green",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Teilnetzwerk Ratsuche",
     sub="38 Knoten mit 75 Kanten")
plot(love, layout=layout_nicely, 
     edge.arrow.size=.2,
     edge.color="red",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Teilnetzwerk Liebe",
     sub="23 Knoten mit 24 Kanten")

# setzt die Darstellung wieder auf eine Abbildung zurück
par(mfrow=c(1,1), mar=c(0,0,0,0))
```


*Teilnetzwerke nach Gewichtung im Vergleich*
Eine weitere Form der Analyse wäre es, die Teilnetzwerke work oder help nach der ersten und zweiten Nennung zu unterteilen. Mit der Annahme, dass die erste Nennung (und damit das Kantengewicht 3) eine höhere Popularität hat als die zweite Nennung lassen sich ggf. Dynamiken innerhalb des Netzwerks aufzeigen.

```{r Teilnetzwerke anhand des Kantengewichts vergleichen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

work <- subgraph.edges(s, E(s)[relation==1]) 
work <- delete_edge_attr(work, "relation")
work <- delete_edge_attr(work, "complicated")
list.edge.attributes(work)
edge.attributes(work)$weight

# aggregiertes Netzwerk
is_simple(work)
ws <- simplify(work,edge.attr.comb=list(weight="sum"))
is_simple(ws)
ws

# unterteilt das Netzwerk in das Hilfsnetzwerk h1 mit einem Gewicht von 1
w1 <- subgraph.edges(work, E(work)[weight==1])
# analog dazu das Hilfsnetzwerk mit einem Gewicht von 3
w3 <- subgraph.edges(work, E(work)[weight==3])
# Vergleich der beiden Netzwerke
w1
w3
ws
# jedes Netzwerk hat jetzt genau 38 Knoten mit 38 Kanten

# die beiden getrennten Netzwerke lassen sich nun einfach mit einer Addition wieder in das ursprüngliche Netzwerk zurückversetzen:
wadd <- w1 + w3
wadd


par(mfrow=c(1,4), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(w3, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="starke Zusammenarbeit, \n Gewicht 3")

plot(w1, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="lightblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n Gewicht 1")

plot(ws, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="blue",
     edge.width=E(s)$weight, # definiert die Kantenstarke nach Gewicht
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n simplifiziert, gewichtet")

plot(wadd, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="black",
     edge.width=E(wadd)$weight, # definiert die Kantenstarke nach Gewicht
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Zusammenarbeit, \n addierte Teilnetzwerke")

# setzt die Ansicht wieder auf einen Graph pro Zeile zurück
par(mfrow=c(1,1), mar=c(0,0,1,2))

```

Interessant in der Analyse ist, dass die bis dahin zweite Komponente aus den Knoten 5,6,12,14,22,26 bei der ersten Nennung noch zusammenbleibt, bei der zweiten Nennung aber in zwei kleinere Komponenten zerfällt (5,22) und (6,12,14,26). Das bedeutet, dass die Dyade 5 und 22 sich sowohl bei der ersten als auch zweiten Nennung beides mal genannt hat. Folglich müsste das Gewicht des aufaddierten Netzwerks bei dieser Dyade den Wert 6 haben. 

Ingesamt zeigt die Analyse, dass die Präferenzen für die Zusammenarbeit sich deutlich stärker zerlegen lässt, wenn man die Teilnetzwerke nach Gewicht erhebt. 

*Teilnetzwerk Beziehung im Vergleich*

```{r Teilnetzwerke anhand des Kantengewichts vergleichen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
list.edge.attributes(s)

love <- subgraph.edges(s, E(s)[relation==3]) 
love
list.edge.attributes(love)

# Das Attribut "complicated" gibt drei Beziehungsarten an, mit denen das Netzwerk weiter unterteilt werden kann.

# Paarbeziehung im Netzwerk love
l_pair <- subgraph.edges(love, E(love)[complicated==1])
# Tinder-Swipe im Netzwerk love
l_tinder <- subgraph.edges(love, E(love)[complicated==2])
# Crush im Netzwerk love
l_crush <- subgraph.edges(love, E(love)[complicated==3])

# Vergleich der beiden Netzwerke
love
l_pair
l_tinder
l_crush

par(mfrow=c(1,4), mar=c(0,0,4,0)) # definiert, dass 3 plots in einer Zeile stehen

plot(love, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="darkblue",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="alle Beziehungen")

plot(l_pair, layout=layout_with_kk,
     edge.arrow.size=.2,
     edge.color="red",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Paarbeziehungen")

plot(l_tinder, layout=layout_with_kk,
     edge.arrow.size=.5,
     edge.color="pink",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Tinder-Swipe")

plot(l_crush, layout=layout_with_kk,
     edge.arrow.size=.5,
     edge.color="lightgreen",
     vertex.color="grey75",
     vertex.frame.color=NA,
     main="Crush")

# setzt die Ansicht wieder auf einen Graph pro Zeile zurück
par(mfrow=c(1,1), mar=c(0,0,1,2))

```

Durch die Teilnetzwerke wird deutlich, dass bei den Paarbeziehungen zwei Triaden vorliegen (16,28,29) und (6,5,22). Entweder haben 28 und 5 jeweils eine Affäre oder sie neigen zur Polyamorie. Die Tinder-Beziehungen (swipes) scheinen nicht stark ausgeprägt zu sein (4 von 38 Befragten haben angegeben, dass sie auf Tinder aktiv sind). Davon mögen sich 33 und 9 gegenseitig auf Tinder und sind auch in einer Beziehung. 31 findet 19 attraktiv, aber nicht umgekehrt. Sehr begehrt im Semester scheint Knoten 23 zu sein, der fünf (heimliche) crushes hat. Knoten 23 findet aber wiederum 17 interessant. Knoten 6 hat zwei crushes. Knoten 16 mag Knoten 18, aber Knoten 18 findet wiederum Knoten 23 attraktiv: eine vertrackte Situation! 

*Analyse der Teilnetzwerke (nach Node-Attributen)*

### 4.2.2 Teilnetzwerke nach Node-Attributen

Die Analyse der Teilnetzwerke nach Node-Attributen werden hier nur exemplarisch am Beispiel Geschlecht und Vertiefungsrichtung gezeigt. Der einfachste Weg ein Teilnetzwerk zu erstellen geht über den Befehl delete.vertices(). Damit werden alle Knoten samt Verbindungen gelöscht, die bestimmte Bedingungen erfüllen. Wenn die Node-Attribute numerisch codiert sind lassen sich logische Operatoren einsetzen.

*Teilnetzwerk Geschlecht*

```{r Teilnetzwerk nach Node-Attribut Geschlecht, fig.height=6, fig.width=10, message=FALSE, warning=FALSE, paged.print=TRUE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

list.vertex.attributes(s)
vertex_attr(s)$sex

s_fem <- delete_vertices(s, V(s)[sex > "1"]) 
s_fem
plot(s_fem, layout=layout_with_kk,
     main="Gesamtnetzwerk: weibliche Akteure",
     edge.color="pink",
     edge.arrow.size=.3,
     vertex.color="pink",
     vertex.frame.color=NA,
     sub="n=29, 110 Kanten")
```

Bereits hier zeigt sich, dass das Netzwerk drei Komponenten zerfällt. Neben die zweite kleinere Komponente (die nur aus Frauen besteht) kommt noch eine kleine Dyade hinzu. 

*Kombination von Node-Attributen*

In diesem Beispiel lassen sich z.B. Geschlecht und Vertiefungsrichtung kombinieren. Die Analyse der jeweiligen Kategorien folgt dabei dem Forschungsziel.

```{r Kombination Geschlecht und Vertiefungsrichtung}
list.vertex.attributes(s)

# Zunächst werden alle Werte gelöscht, die nicht weiblich sind (eins ist als weiblich codiert, also logischer Operator wird > verwendet, d.h. es werden alle männlichen und diversen Knoten gelöscht)
s_fem <- delete_vertices(s, V(s)[sex >"1"]) 

# Dann werden die Journalisten mit dem Wert ein 1 (weil 1 als CR Vertiefung codiert ist) aus dem Netzwerk s_fem gelöscht (in dem nur Frauen sind.)
s_fem_pr <- delete_vertices(s_fem, V(s_fem)[crpr=="1"]) 
s_fem_pr

# Der plot verwendet nur wenig Anpassungen.
plot(s_fem_pr, 
     layout=layout_with_kk,
     main="Netzwerk der PR-Vertieferinnen",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.label.color="grey10",
     vertex.color="pink",
     sub="n=17, 48 Kanten, alle Beziehungsarten")
```


### 4.2.3 Kombination von Edge und Nodeattributen

*Teilnetzwerk Frauen im Hilfsnetzwerk im Altersvergleich*

*Teilnetzwerk Männer bei Ratsuche in der Vertiefung CR*

## 4.3 Teilnetzwerke: Componenten, Cluster und Cliquen

### 4.3.1 Komponenten

### 4.3.2 Cluster

### 4.3.3 Cliquen

## 4.4 Teilnetzwerke: Ego-Netzwerke

### 4.4.1 Egonetzwerke der stärksten Verbindungen (Degree)

### 4.4.2 Egonetzwerke der Broler (betweenness)

## 4.5 Zentralitätsmaße

### 4.5.1 Degree

### 4.5.2 Betweeness und Broker

### 4.5.3 Closeness und Eigenvector

### 4.5.4 Zentralitätsmaße im Vergleich


## 4.6 Transitivität und Homophilie im Netzwerk

### 4.6.1 Transitivität

### 4.6.2 Homophilie

# Visualisiserung

## 5.1 Gesamtnetzwerk

### 5.1.1 Gesamtvisualisierung

```{r Einfache Visualisierung des erstellten Objekt, fig.height=10, fig.width=16, message=TRUE, warning=TRUE, paged.print=TRUE}

# setzt die Ränder (margins) auf 0, schneidet aber manchmal dadurch die Überschrift ab
par(mar=c(0,0,0,0)) 

plot(s,
     asp=0, #definiert, dass der gesamte Raum ausgenutzt werden soll
     layout=layout_with_kk,
     vertex.size=10,
     edge.arrow.size=.3,
     edge.color="grey50",
     edge.curved=curve_multiple(s))

par(mar=c(0,0,0,0)) # setzt die Ränder zurück.
```

Die erste Visualisierung des Netzwerks zeigt, dass es zwei klar getrennte Komponenten im Netzwerk gibt. Zudem zeigt sich, dass drei unterschiedlichen Beziehungsdimensionen eine schnelle Übersicht des Netzwerks erschweren. 

### 5.1.2 Multiplexes Netzwerk
Um das etwas übersichtlicher darszustellen, bietet sich bei einem Netzwerk mit verschiedenen Beziehungsarten an, diese farblich zu unterscheiden. 

```{r Visualisierung eines multiplexe Netzwerke erstellen, fig.height=8, fig.width=10, message=TRUE, paged.print=TRUE}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# definiert die Farbe der Relation
E(s)[E(s)$relation == 1]$color <- "blue" 
E(s)[E(s)$relation == 2]$color <- "darkgreen"
E(s)[E(s)$relation == 3]$color <- "red"

# Visualisierungsparameter festlegen
par(mar=c(6,3,3,3)) 

# Plot mit den gesetzten Farben für das Attribut Beziehung realisieren
plot(s,
     asp=0,
     edge.arrow.size=.5,
     vertex.color="gray75",
     vertex.frame.color="NA",
     vertex.size=8,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, d.h. verschiedene Formen der Beziehung",
     sub="n=38 Knoten; Kantenfarbe 
     blau=Zusammenarbeit, grün=Ratsuche, rot=Beziehung")

par(mar=c(0,0,0,0)) 

```

Die Unterscheidung der unterschiedlichen Netzwerkarten lässt erste Rückschlüsse zu, ist aber immer noch nicht befriedigend. Aus diesem Grund werden nun 


## 5.2 Vergleich der Teilnetzwerke




## 5.3 Wichtige Akteure im Netzwerk

# 6. Diskussion: Fazit, Limitationen und Ausblick

# Anlage
## Literatur

## Codebuch

## Datenmaterial und Skript

## Team, Arbeitsaufwand und Lessons Learned




**igraph-Objekt initialisieren (Beispieldatensatz)**

Denken Sie immmer daran, vor dem Einlesen die entsprechenden Programmpakete zu laden. Die Dateien müssen im CSV-Format vorliegen und werden als Edgelist und Nodelist mit dem Befehl read.csv eingelesen. Achten Sie hierbei, dass die Parameter richtig gesetzt sind (Kopfziele und Trennzeichen). Mit dem Befehl as.matrix erzeugen wir aus der Edgelist eine Matrix. graph_from_data verbindet die Matrix mit der Nodelist und gibt ihr die Bezeichnung "s". Achten Sie hier auf darauf, ob das Netzwerk gerichtet oder ungerichtet ist.

```{r 1 Netzwerk einlesen, echo=FALSE, message=FALSE, warning=FALSE, paged.print=FALSE}

library(igraph)

# Einlesen der Edge- und Nodelist
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")

# Matrix erstellen
edgematrix <-as.matrix(el)

# Zusammenführen von Edge- und Nodelist als igraph-Objekt s
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s
```


## 2 igraph-objekt verstehen
In diesem Kapitel lernen Sie, wie man ein igraph-Objekt schnell interpretiert. Jedes igraph Objekt verfügt über eine feste Konvention, mit der es interpretiert werden kann. Damit sieht man schnell, welche Edge- und Nodeattribute das Netzwerk aufweist.

```{r Netzwerkattribute_verstehen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s
```

In der ersten Zeile wird die "Class", also die Art des Objekts als igraph definiert. Der Code danach identifiziert das Objekt eindeutig. Danach kommen vier mögliche Ausprägungen des Netzwerks

1) gerichtet (D) oder ungerichtet (N)
2) mit Attributen (N) (named)
3) gewichtet (W) (weighted)
4) bipartite oder two-mode (B), d.h. muss das Vertex-Attribute type beinhalten.

Nicht jedes Feld muss belegt sein. 

Danach folgt zunächst die Anzahl der Knoten (V für vertices) und Kanten (E für edges)
  
Danach folgt eine Beschreibung der Attribute. Dabei wird der Name des Attributs zuerst genannt. In den Klammer werden zwei Eigenschaften präzisiert.
e/v Edge- oder Vertex-Attribut
n/c/l numerische (n), textliche (c) oder logische (l) Daten des Attributs.
  
Danach folgt ein Auszug der Beziehungen aus der Edgelist, die grafisch dargestellt sind. Um einen schnellen Überblick über die Anzahl der Knoten und Kanten zu erhalten, helfen uns die ecount(g) für die Anzahl der Edges und vcount(g) für die Anzahl der Kanten (Vertices).

## 3 Netzwerkattribute 
Die Netzwerkattribute lassen sich mit dem Befehl list.vertex.attributes(g) anzeigen für die Node-Atttribute, gleiches gilt für list.edge.attributes(g) für die Kantenattribute. 
  
Sollen die Werte eines bestimmten Attributes ausgewählt werden, dann wird das enstprechende Attribut mit *$* selektiert und mit dem Befehl *edge.attributes(g)* oder *vertex.attributes(g)* gekoppelt. Liegt z.B. das Edge-Attribut "weight", dann lassen sich diese Werte mit dem Befehl *edge.attributes(g)$weight* auslesen.

*Aufgabe*
- Wie viele Vertices und Edges hat das Netzwerk s?  
- Erstellen Sie eine Liste aller Kanten- und Knotenattribute.  
- Zeigen Sie die Werte für das Attribut "relation"" und das Attribut "sex" an. 

```{r Netzwerkattribute lesen}
vertex.attributes(s)
edge.attributes(s)
edge.attributes(s)$weight
```

## 4 Einfache Visualisierung
Mit  *plot(g)* lassen sich einfache Visualisierungen durchführen. Der plot() Befehl überschreibt alle vorher erstellten Parameter und definiert diese nur für diesen plot. Sollen bestimmte Eigenschaften des Netzwerks dauerhaft festgelegt werden, dann ist es einfacher, diese Eigenschaften vorab dauerhaft zu definieren.

Der Layout-Befehl layout_with_kk verwendet den Kamada-Kawai Algorithmus. Sein Vorteil ist, dass die Knoten immer an auf der gleichen Position festgelegt werden. Die Funktion *main=* legt den Titel des Abbildung fest, die Funktion *sub=* den entsprechenden Untertitel.

*Aufgabe*  
- Ändern Sie den Titel der Abbildung.  
- Ändern Sie das verwendete Layout mit dem Fruchterman-Rheingold-Algorithmen (layout_with_fr) 

```{r Einfache Visualisierung}
plot(s,
     layout=layout_with_kk,
     main ="out-of-the-box Visualisierung des Netzwerks")
```

## 5 Netzwerkattribute festlegen
Netzwerkattribute sind hilfreich, um Netzwerke besser zu verstehen. Sie sind wichtige Parameter für die spätere Visualisierung von Netzwerken. Jedes Netzwerk hat zusätzlich zu den erhobenen Attributen feststehende Visualisierungsparameter. Diese lassen sich beliebig manipulieren. Werden die Daten ein Mal festgeschrieben, dann gelten sie für alle weiteren Netzwerke. 

Merke: Die Befehle **V(g)** und **E(g)** erstellen dauerhaft neue Vertex bzw. Edge-Attribute, die mit bestimmten Eigenschaften versehen werden können. Mit $ wird auf die entsprechenden Attribute zugegriffen.Die Attribute lassen sich auch durch "NA" komplett löschen oder durch ein bestehendes Attribut wieder ergänzen. 

Beispielsweise wird hier die Füllfarbe eines Knotens auf dunkelorange definiert V(s)$color<-"darkorange". Mit vertex.attributes(g)$color kann dieser Wert angezeigt werden. Der Rahmen eines Knoten kann durch die Zuweisung des Wert "NA" ausgeblendet werden V(g)$frame.color<-"NA". Dies gilt auch für Kantenattribute. Beispielsweise lassen sich die Pfeilspitzen auf den Wert .2 setzen E(s)$arrow.size<-.2 oder die Farbe der Kanten entsprechend festlegen E(s)$color<-"darkorange"

Manchmal ist es hilfreich die Labels auszublenden V(s)$label<-NA. Um diese wieder herzustellen das Vertex-Attribut "Label" mit dem Wert des Vertex-Attributs "Name" wieder überschrieben: V(s)$label<-V(s)$name. 
Eine Übersicht aller Edge- und Vertex-Attribute, die mit diesen Befehlen verändert werden können liefert die Hilfefunktion ?igraph.plotting

**Aufgabe**  
- Die Visualisierung des Netzwerks soll dauerhaft folgende Farben haben:
- Die Knoten in "darkblue"" mit einem Rand in "lightblue""
- Die Kanten in "lightblue"" mir einer Pfeilspitze von .3
- Eine neue, passende Hauptüberschrift und Unterüberschrift

```{r Netzwerkattribute_manipulieren}

?igraph.plotting

V(s)$color <- "darkorange"
V(s)$frame.color <- "NA"
E(s)$arrow.size <- .2
E(s)$color <- "darkorange"

plot(s,
     layout=layout_with_kk,
     main ="Visualisierung mit geänderten Attributen")

```

## 6 Visualisierung verbessern
Wir lesen jetzt das Netzwerk erneut ein, da wir die oben gesetzten Attribute überschreiben wollen. Dann wird das Netzwerk verschönert und optimiert. 

Dabei werden wir die Ränder (margins) des Plotbereichs mit dem Befehl par() auf 0 setzen. Dazu wird ein Vector angelegt, der für die Ränder auf allen Kantenseiten auf 0 setzt.

Im Plotbefehl selbst sind folgende verwenden wir folgende Argumente:
asp=0 definiert, dass die Verhältnisse im Netzwerk erhalten bleiben sollen. Wir legen die Größe der Knoten mit 10 Punkt fest und die Farbe der Kanten in einen abgestuften Graubereich. 

Das wichtigste neue Argument ist, dass die Kanten des Netzwerks S nun als so gekrümmt dargestellt werden sollen edge.curved, dass sich auch mehrfache Beziehungen nicht überlagern.

```{r nice_visualzation, exercise=TRUE, exercise.lines = 15}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

par(mar=c(0,0,0,0)) 

plot(s,
     asp=0, 
     layout=layout_with_kk,
     vertex.size=10,
     edge.arrow.size=.4,
     edge.color="grey50",
     edge.curved=curve_multiple(s))

par(mar=c(0,0.5,0.5,0)) 
```

**Aufgabe**
Verwenden Sie Ihre Kenntnisse aus dem Tutorial und erstellen eine ähnliche Visualisierung ihres Datensatzes. Dies geht ungefähr bis zu einer Größe von 50 Knoten relativ gut. Wenn Sie über 200 Knoten haben, werden Sie keine sinnvolle Visualisierung erstellen können. Sie lernen im nächsten Tutorial, wie sich *Teilnetzwerke* visualisieren lassen.

Achten Sie auf folgende Punkte bzw. ändern einige Parameter:
- Farben und Größe der Knoten und Farbe Knotenrahmen,   
- Farbe der Kanten,  
- ggf. Algorithmus verändern,  
- Titel des Netzwerks hinzufügen,  
- Seitenränder verändern.  

Eine Aufstellung über die in R verwendeten Farben erhalten Sie über den Befehl colors().

*Achtung: Für die Ausgabe einer höher auflösenden Visualisierung sind hier die Höhe und Breite des Plots auf 12 und 16 inches definiert. 

```{r Einfache Visuaslisierung, fig.height=12, fig.width=16}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

par(mar=c(0,0,0,0)) 

plot(s,
     asp=0, 
     layout=layout_with_kk,
     vertex.size=10,
     edge.arrow.size=.4,
     edge.color="grey50",
     edge.curved=curve_multiple(s))

par(mar=c(0,0.5,0.5,0)) 
```

# II. Netzwerke selektieren

## 1 Teilnetzwerk nach Edge-Attributen
Verfügt das Netzwerk über entsprechende Edge-Attribute list.edge.attributes() lässt sich das Netzwerk durch die Auswahl spezifischer Edge-Attribute und dem Befehl subgraph.edges() erstellen. Der Befehl erstellt ein komplettes Unternetzwerk mit allen Node-Attributen. 

Der Befehl subgraph.edges ist wie folgt aufgebaut:
subgraph.edges(g, E(g)[Selektion des Attributs]) und liest sich wie folgt: Erstelle ein neues Netzwerk aus dem Netzwerk g, indem das Netzwerk basierend auf dem logischen Operator aus dem Edge-Attribut von g gewählt wird.

Wichtig ist es hier, das Netzwerk neu zu benennen.

```{r subgraph_edges}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)


list.edge.attributes(s)
edge.attributes(s)$relation

work <- subgraph.edges(s, E(s)[relation==1]) 
work

plot(work,
     edge.arrow.size=.3,
     layout=layout_with_kk,
     edge.color="blue",
     edge.curved=.2,
     edge.curved=curve_multiple(work),
     main="Teilnetzwerk Zusammenarbeit",
     sub="n=38, KK-Algorithmus")
```

**Aufgabe**
Erstellen Sie ein Teilnetzwerk "help"" mit der Kantenfarbe "green" und ein Teilnetzwerk "love" mit der Kantenfarbe "red". Benennen Sie das Netzwerk entsprechend. Erstellen Sie dann ein Teilnetzwerk von Studierenden, die eine Paarbeziehung haben und nennen dieses Teilnetzwerk "relationship" (Tipp: Sie müssen dafür ins Codebuch des Datensatzes schauen und die Edge-Attribute entsprechend analysieren).


```{r Übung Teilnetzwerke erstellen}



```


## 2 Multiplexe Netzwerke visualisieren
Multiplexe Netzwerke haben mehr als nur eine Kantenart, d.h. es werden mehrere Beziehungsarten im gleichen Graphen visualisiert. Dazu gibt es zwei Möglichkeiten (die sich auch kombinieren lassen): Farben und Formen. Achtung: multiplexe Netzwerke werden leicht unübersichtlich, deshalb sollte die Visualisierung immer mit Bedacht vorgenommen werden.

*Kantenfarben* verwenden: wir haben in dem Edge-Attribut "relation" zwei Werte angebgeben, nämlich "1" (work) und "2" (help), die unterschiedliche Beziehungen beschreiben. Die Kanten lassen sich entsprechend einfärben.

```{r Multiplexe Netzwerke erstellen}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

# definiert die Farbe der Relation
E(s)[E(s)$relation == 1]$color <- "blue" 
E(s)[E(s)$relation == 2]$color <- "green"
E(s)[E(s)$relation == 3]$color <- "red"


# Visualisierungsparameter festlegen
par(mar=c(0,0,1,0)) 

plot(s,
     asp=0,
     edge.arrow.size=.2,
     vertex.color="gray90",
     vertex.frame.color="white",
     vertex.size=10,
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, d.h. verschiedene Formen der Beziehung",
     sub="n=38, blau=Zusammenarbeit, grün=Ratsuche, rot=Beziehung")
```

**Aufgabe**
Visualisieren Sie nur das Zusammenarbeitsnetzwerk work in "lightblue". Visualisieren Sie nur das Beziehungsnetzwerk love in "red". Alle weiteren Beziehungen werden im Farbwert "grey20" dargestellt.  

```{r Übung multiplexes Netzwerk Farbänderungen}


```


## Einsatz von Kantenformen

*Kantenformen* verwenden: Neben den Vertex-Formaten lassen sich auch die Kanten visuell anpassen. Hier stehen verschiedene Formen zur Verfügung: 0 or “blank”, 1 or “solid”, 2 or “dashed”, 3 or “dotted”, 4 or “dotdash”, 5 or “longdash”, 6 or “twodash”. Die Codierung ist vorgegeben und als edge.lty definiert. lty steht für Linetype, also die Art der Linie, die verwendet wird.

```{r Multiplex Kantenformen}
E(s)[E(s)$relation == 1]$lty <-2 # dashed (work)
E(s)[E(s)$relation == 2]$lty <-3 # dotted (help)
E(s)[E(s)$relation == 3]$lty <-4 # dotdash (love)

# Visualisierung des multiplexen Netzwerks
plot(s,
     asp=0,
     edge.arrow.size=.2,
     edge.color="black",
     vertex.color="gray90",
     vertex.frame.color="white",
     layout=layout_with_kk,
     edge.curved=curve_multiple(s),
     main="Multiplexes Netzwerk, Format der Kanten",
     sub="n=38, work=dashed, help=dotted, love=dotdash")
```

**Aufgabe**
Visualisieren Sie aus dem Hauptnetzwerk s das Zusammenarbeitsnetzwerks in roter Farbe und gepunktet.

```{r Übung: Multiplexes Netzwerk in Farben und Formen darstellen}
par(mar=c(0,0,0,0)) 


```

## 3 Teilnetzwerke nach Vertex-Attributen
Teilnetzwerke lassen sich auch nach Vertex-Attributen erstellen. Dabei wird der Befehl delete_vertices(g). Damit werden Knoten gelöscht, die eine bestimmtes Vertex-Attribut aufweisen. Das bedeutet, dass die Auswahl des Netzwerks immer aufgrund der gelöschten Attribute erfolgt. Sollen z.B. das Netzwerk nur aus Männern bestehen, müssen alle Knoten mit den Attributen, die nicht Männer sind, gelöscht werden. Dazu helfen die logischen Operatoren. Wie im Beispiel unten werden z.B. alle Werte ausgewählt, die größer 1 sind. Alternativ könnte man auch auch den logischen Operator ist nicht != verwenden, der alle Werte ausser dem angegebenen löscht.

Wichtig ist es hier, das Netzwerk neu zu benennen.

```{r delete_vertices, exercise=TRUE, exercise.lines = 15}
library(igraph)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)

list.vertex.attributes(s)
vertex_attr(s)$sex

s_fem <- delete_vertices(s, V(s)[sex > "1"]) 
s_fem
plot(s_fem, layout=layout_with_kk,
     main="Netzwerk, nur weiblich",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="n=29, 110 Kanten")
```

**Aufgabe**
Erstellen Sie ein männliches Unternetzwerk, färben die Knoten in "lightblue" und fügen passende Überschriften hinzu mit der Anzahl der Knoten und Kanten.

```{r Übung Nezwerk nur männlich, exercise=TRUE, exercise.lines = 30}



```

*Verknüpfte Bedingungen*
In diesem Beispiel wollen wir nur Knoten haben, die weiblich sind und PR vertiefen. Im Codebuch ist der Wert für weiblich für das Vertex-Attribut sex mit 1 codiert, die Variable PR ist als Vertex-Attribut crpr mit dem Wert 2 codiert. 

Achten Sie darauf, dass zunächst ein Unternetzwerk s_fem erstellt wird und aus diesem Unternetzwerk ein zweites Netzwerk der Vertiefer erstellt wird!


```{r Netzwerk mit Bedingungen selektieren}
list.vertex.attributes(s)

# Zunächst werden alle Werte gelöscht, die nicht weiblich sind (eins ist als weiblich codiert, also logischer Operator wird > verwendet, d.h. es werden alle männlichen und diversen Knoten gelöscht)
s_fem <- delete_vertices(s, V(s)[sex >"1"]) 

# Dann werden die Journalisten mit dem Wert ein 1 (weil 1 als CR Vertiefung codiert ist) aus dem Netzwerk s_fem gelöscht (in dem nur Frauen sind.)
s_fem_pr <- delete_vertices(s_fem, V(s_fem)[crpr=="1"]) 
s_fem_pr

# Der plot verwendet nur wenig Anpassungen.
plot(s_fem_pr, 
     layout=layout_with_kk,
     main="Netzwerk der PR-Vertieferinnen",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.label.color="grey10",
     vertex.color="pink",
     sub="n=17, 48 Kanten, alle Beziehungsarten")
```

**Aufgabe**
Erstellen Sie ein Netzwerk der männlichen Journalismus-Vertiefer, die noch eine weitere Bedingung umfasst und benennen Sie das Netzwerk entsprechend.

```{r Übung Netzwerkselektion}
list.vertex.attributes(s)

```


## 4 Kombination von Edge- und Vertex-Attributen
Natürlich lassen sich alle Varianten auch gemeinsam kombinieren zu einem Grand Finale:

Uns interessiert jetzt ein das weibliche Unterstützungsnetzwerk von Personen, sich sich stark unterstützen und die über 23 Jahre alt sind. Wie sieht die Beziehung zwischen diesen Personen aus?


```{r Übung: Grand finale}
list.vertex.attributes(s)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

# Schritt 1: Trennung in das Unterstützungsnetzwerk
help <- subgraph.edges(s, E(s)[relation==2]) 
help

# Schritt 2: Selektion weight=3 
help_strong <- subgraph.edges(help, E(help)[weight==3])

# Wir wollen nun wissen, wie das Ratsuche-Netzwerk unter Frauen aussieht:
fem <- delete_vertices(help_strong, V(help_strong)[sex != "1"]) # löscht alle nicht weiblichen Knoten

plot(fem,
     layout=layout_with_kk,
     main="Unterstützungsnetzwerk weiblich",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="weiblich, starke Beziehung")


fem_old <- delete_vertices(fem, V(fem)[age < "3"])
fem_old
plot(fem_old, layout=layout_with_kk,
     main="Unterstützungsnetzwerk weiblich (fem_old)",
     edge.color="grey80",
     edge.arrow.size=.3,
     vertex.color="pink",
     sub="weiblich, Alter über 23, starke Beziehung")

# Es zeigt sich, dass nur eine (reziproke) Beziehung beim weiblichen Unterstützungsnetzwerk der über 23-jährigen übrig bleibt, nämlich zwischen Knoten 38 und 29. Um diese Dyade besser darzustellen können alle isolates, also Knoten, die nicht miteinander verbunden sind, gelöscht werden.

# der Befehl delete.vertices löscht alle Knoten aus dem Netzwerk fem_old, die einen degree-Wert von 0 haben, also mit keinem anderen Knoten verbunden sind. 
fem_old2 <- delete.vertices(fem_old, degree(fem_old)==0)
fem_old2

plot(fem_old2, layout=layout_with_kk,
     main="Dyade ohne Isolates",
     edge.arrow.size=.7,
     edge.width=E(s)$weight,
     edge.color="pink",
     vertex.size=30,
     vertex.color="pink",
     vertex.frame.color="black",
     vertex.frame.color="white",
     vertex.label.color="black",
     sub="Dyade zweier Frauen über 23, die sich gegenseitig stark unterstützen")
```

**Abschlussaufgabe**
Erstellen Sie ein Teilnetzwerk mit folgenden Bedingungen: Gesucht werden männliche Journalisten, die überwiegend zusammenarbeiten und auf Tinder aktiv sind.

Überlegen Sie zuerst anhand des Codebuchs, welche Schritte notwendig sind, damit Sie zunächst Teilnetzwerke selektieren und dann visualisieren können.


```{r grand_finale_ex, exercise=TRUE, exercise.lines = 15}
list.vertex.attributes(s)
el <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/edges.csv", header=T, as.is=T, sep = ",")
nodes <- read.csv("https://raw.githubusercontent.com/hdm-crpr/226305/master/data/crpr2/nodes.csv", header=T, as.is=T, sep = ",")
edgematrix <-as.matrix(el)
s <- graph_from_data_frame(d=edgematrix, vertices=nodes, directed=T)
s

```




